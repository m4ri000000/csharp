#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

Hola! En este notebook voy a cometarte los distintos tipo de métodos que hemos visto en Programación relacionados a los *string*, entendiendo por string aquel tipo de dato que se utiliza para almacenar secuencias de caracteres, como por ejemplo: 

#!csharp

string saludo = "Hola!";

Console.Write(saludo);

#!markdown

Los strings en C# son inmutables, es decir, cuando usamos metodos para conseguir subcadenas, valores, indices u otras informaciones, no estamos cambiando el string original, sino estamos generando nuevas cadenas con las subcadenas que vamos extrayendo.

#!markdown

Una de las primeras propiedades que debemos aprender de los string es *.Length*. Es una propiedad que nos permite saber la cantidad de caracteres que contiene nuestro string, podemos implementarla así:

#!csharp

string cadena = "Hola! Esto es un ejemplo de como usar Length en csharp.";

Console.WriteLine($"La cadena tiene {cadena.Length} caracteres.");

#!markdown

Como puedes ver, simplemente nos permite saber cuantos caracteres hay en un string, algo que usaremos en varias ocasiones, dado que nos permite recorrer la cadena (en caso de que estemos buscando un caracter o otra cadena dentro de la misma) o verificar sus dimensiones para poder realizar comparaciones, incrementos, etc.

#!markdown

Mira este sencillo ejemplo en el que usamos .Length para imprimir algo sobre la cadena que escribimos.

#!csharp

string palabra = "increible"; /*he escrito la palabra directamente aquí, pero podía usar
un Console.Write("Escribe palabra: ") y un Console.ReadLine()*/

int longitud = palabra.Length;

Console.WriteLine($"La palabra '{palabra}' tiene {longitud} caracteres.");

if (longitud > 5)
{
    Console.WriteLine("¡Esa es una palabra bastante larga!");
}
else
{
    Console.WriteLine("Esa es una palabra corta.");
}

#!markdown

Otra propiedad de los strings es *.Replace* que permite **reemplazar** las apariciones de una subcadena específica por otra dentro de un string.

#!csharp

string result = cadena.Replace("texto_original", "nuevo_texto");

// texto_original es la cadena que deseo remplazar
// nuevo_texto es la cadena que remplazará a texto_original

#!csharp

string frase = "Hola user1!";
string nuevaFrase = frase.Replace("user1!", "user2!");
Console.WriteLine(nuevaFrase);

#!markdown

Como ves, selecciono la parte de la cadena (subcadena) que quiero modificar ("user1!") y, separando con una coma, escribo con que quiero remplazarla ("user2!).

#!markdown

Otra propiedad de los strings es la posibilidad de pasar la totalidad de la cadena a mayúsculas (.ToUpper) y a minúsculas (.ToLower).

#!csharp

string frase = "Hola Mundo!";

string minusculas = frase.ToLower();
Console.WriteLine($"En minúsculas: {minusculas}");

string mayusculas = frase.ToUpper();
Console.WriteLine($"En mayúsculas: {mayusculas}");

#!markdown

Vamos a complicarlo un poco, como hemos visto los string son cadenas de caracteres pero, ¿puede haber un string que no contenga ningún dato? Pues sí, se trata de un string que tiene como valor **null**. El valor null es un valor especial que indica que la variable no ha sido inicializada o no contiene ningún dato.

#!csharp

string texto = null;
Console.WriteLine(texto); //no imprime nada

#!markdown

¿Es una cadena null lo mismo que una cadena vacía ("")? No, la cadena que tiene como valor null no contiene ningún objeto, ni siquiera una cadena vacía. Mientras una cadena vacía tiene una longitud de 0, es decir, sigue siendo un objeto (de tipo string).

#!csharp

string texto1 = null;
string texto2 = "";

Console.WriteLine(texto1 == null); // True
Console.WriteLine(texto2 == "");  // True
Console.WriteLine(texto1 == texto2); // False, porque uno es null y el otro es una cadena vacía

#!markdown

Es importante asegurarse que un string no sea null ya que intentar acceder a él conllevaría errores (NullReferenceException).

#!csharp

string texto = null;

Console.WriteLine(texto.Length) //me dará error

#!csharp

string texto = "hola!";

if (texto != null)
{
    Console.Write(texto);
}

#!markdown

Para que se entienda, usamos null cuando no hemos asignado ningun valor a una cadena (o decir que no tiene ningún valor significativo), y una cadena vacía cuando queremos decir que se trata de una variable válida pero sin texto. (Imagina un formulario, usamos *null* para decir que el usuario no ha proporcionado ninguna informacion todavia, y usamos una cadena vacia para decir que el usuario si ha proporcionado informacion, lo que sin ningun tipo de dato).

#!markdown

Vamos a adentrarnos en los métodos más usados (y que debes aprender por ahora) de Strings. Vamos a ver los mecanismos detrás de cada uno de ellos solo con bucles, y luego usaremos los métodos para que veas la lógica detrás de los mismos.

#!markdown

Vamos a empezar por **IndexOf**, un metodo que usamos para encontrar la posicion de la primera aparicion (para la ultima usamos LastIndexOf). Devuelve el *indice* de la primera coincidencia, en caso de que no haya, devuelve -1. 

#!csharp

string frase = "Hola mundo";
int indice = frase.IndexOf("mundo");
Console.WriteLine(indice); // Imprime 5 ya que ese es el indice (posicion) en el que encuentra la subcadena mundo

#!markdown

Vamos a ver como desarrollariamos el programa anterior sin usar index of, pero usando la logica y los mecanismos detras del metodo.

#!csharp

string frase = "Hola mundo"; //escribimos la cadena
string subcadena = "mundo"; //escribimos la subcadena que queremos encontrar
int indice = -1; //empiezo el indice manualmente en -1 para decir que aun no hemos encontrado la subcadena

//vamos a usar un bucle for para recorrer la cadena
for (int i = 0; i <= frase.Length - subcadena.Length; i++) /*realizamos la resta de la subcadena y la cadena para que no intente substraer
una cadena mayor que la original (en este caso, 10 - 5 = 5)*/
{
    bool coincide = true; //creamos un booleano coincide que, en caso de que se cumplan los requisitos, permanecera como true confirmando la presencia de la subcadena en la cadena.
    for (int j = 0; j < subcadena.Length; j++) //incrementamos j
    {
        if (frase[i + j] != subcadena[j]) //aqui vemos el carácter de la frase en la posición actual i desplazado por j. Esto asegura que estamos comparando los caracteres de la frase con los de la subcadena correctamente.
        {
            coincide = false;
            break; //si no coincide, rompemos el bucle interno
        }
    }

    if (coincide)
    {
        indice = i;
    }
}

Console.WriteLine(indice); //Imprime 5 si se encuentra "mundo"

#!markdown

Como ves el resultado es el mismo, simplemente hemos visto los mecanismos detras de IndexOf (empezar en -1, recorrer toda la cadena si la subcadena es menor que la cadena, analizar si cada caracter de la subcadena (j) existe dentro de la cadena, y en caso de que asi sea, imprimir la primera iteracion (que hemos asignado justamente a indice) en la que encuentra la subcadena).

#!markdown

Ademas de ver la posicion, podemos saber directamente si una subcadena existe o no dentro de una cadena o, en otras palabras, si una cadena *contiene* una subcadena. Para ello, usamos el metodo de strings **Contains**. Mira aquí un ejemplo: 

#!csharp

string frase = "Hola mundo";
bool contiene = frase.Contains("mundo");  // Devuelve true

Console.WriteLine(contiene);  // Imprime: true

#!markdown

Contains es sensible a mayusculas y minusculas, como casi todo en csharp, por lo que la frase "Hola mundo" no contiene la subcadena "Mundo".

#!csharp

string frase = "Hola Mundo";
bool contiene = frase.Contains("mundo");  // Devuelve false
Console.WriteLine(contiene);  

#!markdown

Si queremos ignorar las mayusculas y minusculas, podemos añadir los ToUpper y ToLower vistos anteriormente.

#!csharp

string frase = "Hola Mundo";
bool contiene = frase.ToLower().Contains("MUNDO".ToLower());  // Devuelve true
Console.WriteLine(contiene);  

#!markdown

Como con IndexOf, vamos a ver la logica detras de Contains, esta vez con un while pero, si analizas el codigo, te daras cuenta de que el patron es el mismo, vamos a asegurarnos siempre de que la subcadena sea menor que la cadena (i <= frase.Length - subcadena.Length) y vamos a recorrer con i todos los caracteres de la frase, y con j todos los de la subcadena, para luego compararlos mediante (frase[i + j] != subcadena[j]).

#!csharp

string frase = "Hola mundo";
string subcadena = "mundo";
bool contiene = false;  // Inicializamos como false, ya que aún no hemos encontrado la subcadena.

int i = 0;
while (i <= frase.Length - subcadena.Length)  // El bucle continúa mientras podamos comparar la subcadena
{
    bool coincide = true;  // Asumimos que la subcadena puede coincidir
    for (int j = 0; j < subcadena.Length; j++)
    {
        if (frase[i + j] != subcadena[j])  // Comparamos cada carácter
        {
            coincide = false;
        }
    }

    if (coincide)  // Si la subcadena coincide completamente
    {
        contiene = true;
    }

    i++;  // Pasamos al siguiente carácter en la cadena
}

Console.WriteLine(contiene);  // Imprime: true

#!markdown

Como puedes ver, la logica es igual, esta vez simplemente hemos hecho que devuelva un valor booleano (true/false) pero podriamos hacer que el programa imprima tambien algo como:

#!csharp

string frase = "Hola mundo";
string subcadena = "mundo";
bool contiene = false;  // Inicializamos como false, ya que aún no hemos encontrado la subcadena.

int i = 0;
while (i <= frase.Length - subcadena.Length)  // El bucle continúa mientras podamos comparar la subcadena
{
    bool coincide = true;  // Asumimos que la subcadena puede coincidir
    for (int j = 0; j < subcadena.Length; j++)
    {
        if (frase[i + j] != subcadena[j])  // Comparamos cada carácter
        {
            coincide = false;
        }
    }

    if (coincide)  // Si la subcadena coincide completamente
    {
        contiene = true;
    }

    i++;  // Pasamos al siguiente carácter en la cadena
}

if(contiene)
{
    Console.WriteLine("la subcadena existe en la cadena!");
}

#!markdown

Como ves en este caso he usado un while, pero la logica es exactamente la misma del bucle for, simplemente he cambiado el orden sintactico de las condiciones, el programa sigue siendo el mismo y podrias hacerlo de la misma manera con un bucle for. Prefiero usar el while ya que conlleva a ejecutar el bucle independientemente de las otras condiciones, con tal de que la subcadena sea menor que la cadena, se ejecuta. 

#!markdown

Seguimos con el metodo .Insert que se utiliza para insertar una cadena dentro de otra en una posición específica. Modifica la cadena original al agregar una subcadena en el índice que se le indique.

#!csharp

string frase = "Hola mundo";
string resultado = frase.Insert(5, "hermoso ");
Console.WriteLine(resultado);  // Imprime: Hola hermoso mundo

#!markdown

Vamos a ver como realizar un .Insert solo con unos bucles, usaremos dos bucles for para ello.

#!csharp

string frase = "Hola mundo";
string subcadena = "hermoso ";
int indice = 5;  // La posición donde vamos a insertar la subcadena.

string resultado = ""; //cadena vacia, no null

for (int i = 0; i < indice; i++)  // Recorrer la primera parte de la cadena hasta la posición de inserción
{
    resultado += frase[i];
}

resultado += subcadena;  // Insertamos la subcadena en la posición deseada. (resultado = resultado (frase[i]) + subcadena)

for (int i = indice; i < frase.Length; i++)  // Recorre la segunda parte de la cadena después de la posición de inserción
{
    resultado += frase[i];
}

Console.WriteLine(resultado);  // Imprime: Hola hermoso mundo

#!markdown

Bien, por ultimo veremos como hacer para saber informacion sobre una cadena mediante una subcadena, por ejemplo: imagina tener una cadena y querer saber que subcadena existe en una determinada posicion, o entre un indice y otro, podemos hacer todo esto mediante un nuevo metodo que es el metodo **.Substring**. 

#!csharp

string frase = "Hola mundo";
string subcadena = frase.Substring(5); // Empieza en el índice 5 y toma hasta el final
Console.WriteLine(subcadena);  // Imprime: mundo

#!markdown

Tambien podemos poner pedir la subcadena que se encuentra desde un indice hasta otro:

#!csharp

string frase = "Hola mundo";
string subcadena = frase.Substring(5, 5); // Empieza en el índice 5 y toma 5 caracteres
Console.WriteLine(subcadena);  // Imprime: mundo

#!markdown

Si el índice es mayor que la longitud de la cadena o si el rango de longitud solicitado excede el tamaño de la cadena, se lanzará una excepción (ArgumentOutOfRangeException). Recuerda tambien que los strings en C# son inmutables, .Substring no modifica la cadena original, sino que devuelve una nueva cadena con la subcadena extraída.
